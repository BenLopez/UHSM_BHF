print(paste0("Finished reading csv files - ",wavename))
WaveDataT = do.call("rbind",WaveData)
print("Rbind complete")
print(dim(WaveDataT))
nrow(WaveDataT)
WaveData = WaveDataT
rm(WaveDataT)
names(WaveData)
WaveData$Value = as.numeric(WaveData$Value)
grepl("ECG", wavename)
qcut = c(-200,200) # unusual calibration threshold - ask Sam
WaveData$Value[WaveData$Value >= qcut[2] | WaveData$Value <= qcut[1]] = NA
WaveData = subset(WaveData, !is.na(WaveData$Value))
print(dim(WaveData))
length(sub_pat)>0
FirstITUEntry = as.POSIXct(sub_pat$FirstITUEntry)
LastITUEntry = as.POSIXct(sub_pat$LastITUEntry)
FirstITUEntry
sub_pat
sub_pat$FirstITUEntry
?as.POSIXct
grepl("//",as.POSIXct)
?Grepl
?grepl
grepl("//",as.POSIXct, perl = TRUE)
grepl("//",sub_pat$FirstITUEntry, perl = TRUE)
grepl("/",sub_pat$FirstITUEntry, perl = TRUE)
as.POSIXct(sub_pat$FirstITUEntry)
?as.POSIXct
as.POSIXct(sub_pat$FirstITUEntry, "%d/%m/%Y %H:%M")
as.POSIXct(sub_pat$FirstITUEntry, format = "%d/%m/%Y %H:%M")
if(length(sub_pat)>0){
if (grepl("/",sub_pat$FirstITUEntry, perl = TRUE)){
FirstITUEntry = as.POSIXct(sub_pat$FirstITUEntry, format = "%d/%m/%Y %H:%M")
LastITUEntry = as.POSIXct(sub_pat$LastITUEntry, format = "%d/%m/%Y %H:%M")
} else {
FirstITUEntry = as.POSIXct(sub_pat$FirstITUEntry)
LastITUEntry = as.POSIXct(sub_pat$LastITUEntry)
}
} else {
warning("No Patient Info provided")
FirstITUEntry = min(WaveData$Date)
LastITUEntry = max(WaveData$Date)
}
FirstITUEntry
LastITUEntry
#Post Dates
WaveData$InInterval = WaveData$Date > LastITUEntry
ExtraWave = subset(WaveData, WaveData$InInterval == TRUE)
print(dim(ExtraWave))
if (dim(ExtraWave)[1]>0){
ExtraWave$InInterval = NULL
if (choose_outputs[1] == 1){
write.csv(ExtraWave,paste0(pathOutFilesExtra,wavename,"ExtraPost.csv"), row.names=FALSE)
}
if (choose_outputs[2] == 1){
writeMat(paste0(pathOutFilesExtra,wavename,"ExtraPost.mat"), Wave = ExtraWave)
}
if (choose_outputs[3] == 1){
save(file=paste0(pathOutFilesExtra,wavename,"ExtraPost.RData"), list = "ExtraWave")
}}
#Pre Dates
WaveData$InInterval = WaveData$Date < FirstITUEntry
ExtraWave = subset(WaveData, WaveData$InInterval == TRUE)
print(dim(ExtraWave))
if (dim(ExtraWave)[1]>0){
ExtraWave$InInterval = NULL
if (choose_outputs[1] == 1){
write.csv(ExtraWave,paste0(pathOutFilesExtra,wavename,"ExtraPre.csv"), row.names=FALSE)
}
if (choose_outputs[2] == 1){
writeMat(paste0(pathOutFilesExtra,wavename,"ExtraPre.mat"), Wave = ExtraWave)
}
if (choose_outputs[3] == 1){
save(file=paste0(pathOutFilesExtra,wavename,"ExtraPre.RData"), list = "ExtraWave")
}
}
WaveData$InInterval = (WaveData$Date > LastITUEntry) | (WaveData$Date < FirstITUEntry)
WaveData = subset(WaveData, WaveData$InInterval == FALSE)
print(dim(WaveData))
WaveData = subset(WaveData, !is.na(Value))
print(dim(WaveData))
WaveData$InInterval = NULL
start_time = min(WaveData$Date, na.rm = TRUE)
stop_time = max(WaveData$Date, na.rm = TRUE)
print(start_time)
print(stop_time)
if (stop_time>start_time){
seq_times = unique(c(seq(start_time,stop_time,3*60*60),stop_time))} else {seq_times = c(start_time,stop_time)}
seq_times
pathOutFiles = paste0(path,wavename,"_clean/")
dir.create(pathOutFiles, showWarnings = FALSE)
char_name = paste0(PatientCode,"_",wavename,"_file_")
if (choose_outputs[1] == 1 | choose_outputs[2] == 1){
for (lenX in 2:length(seq_times)){
sub_Wave = subset(WaveData, Date<seq_times[lenX] & Date>=seq_times[lenX-1])
if (dim(sub_Wave)[1]>0){
filename = gsub(" ","_",paste0(c(char_name,sprintf('%0.5d', lenX-1),"_",as.character(seq_times[lenX-1]),".csv"),sep = "",collapse = ""))
filenameMAT = gsub(" ","_",paste0(c(char_name,sprintf('%0.5d', lenX-1),"_",as.character(seq_times[lenX-1]),".mat"),sep = "",collapse = ""))
filename = gsub(":","_",filename)
filenameMAT = gsub(":","_",filenameMAT)
if (choose_outputs[1] == 1){
write.csv(sub_Wave,file = paste0(pathOutFiles,filename, sep = "", collapse = ""), row.names=FALSE)
}
if (choose_outputs[2] == 1){
writeMat(paste0(pathOutFilesMAT,filenameMAT, sep = "", collapse = ""), Wave = sub_Wave)
}
}
}
}
if (choose_outputs[3] == 1){
save(file = paste0(pathZIPs, wavename, "_",PatientCode,".RData"), list = "WaveData", compress = "bzip2", compression_level = )
if(Use7z == 1){
Sys.setenv(
PATH = paste(
Sys.getenv("PATH"),
"C:\\Program Files\\7-Zip",
sep = ";"
)
)
systCom = paste0('7z a ',paste0(pathZIPs, wavename,"_",PatientCode,"_RData.7z -o"),pathZIPs, " ", paste0(pathZIPs, wavename, "_",PatientCode,".RData"))
system(systCom)
}
}
if (choose_outputs[1] == 1){
if(UseZip == 1){
zipfiles("test.vbs", paste0(PatientCode,"_",wavename,"_clean.zip"),pathZIPs, paste0(path, wavename,"_clean"))
}
if(Use7z == 1){
Sys.setenv(PATH = paste(Sys.getenv("PATH"),
"C:\\Program Files\\7-Zip",
sep = ";"))
systCom = paste0('7z a ',paste0(pathZIPs, "\\",PatientCode,"_",wavename,"_clean.7z -o"),paste0(path, wavename, "_clean"), " ", paste0(path, wavename,"_clean\\*"))
system(systCom)
}
}
if (choose_outputs[2] == 1){
if(UseZip == 1){
zipfiles("testMAT.vbs", paste0(PatientCode,wavename,"_cleanMAT.zip"),pathZIPs, paste0(path,wavename,"_cleanMAT"))
}
if(Use7z == 1){
Sys.setenv(PATH = paste(Sys.getenv("PATH"),
"C:\\Program Files\\7-Zip",
sep = ";"))
systCom = paste0('7z a ',paste0(pathZIPs, "\\",PatientCode,"_",wavename,"_cleanMAT.7z -o"),paste0(path, wavename, "_cleanMAT"), " ", paste0(path, wavename,"_cleanMAT\\*"))
system(systCom)
}
}
PatientCode
# Select directory containing source
pathFiles = choose.dir(caption="Select folder with source code")
pathFiles = paste0(pathFiles, "\\")
filetype = select.list(c('csv' , 'RData'), preselect = NULL, multiple = TRUE,
title = 'Choose File Type For Patient Index', graphics = TRUE )
if(filetype == 'csv'){
path_PatIndex = choose.files(caption="Select 2017 PatientIndex.csv file")
if(length(path_PatIndex)>0){
PatIndex2017 = read.csv(file=path_PatIndex, stringsAsFactors = FALSE)
# PatIndex2017$FirstITUEntry=as.POSIXct(PatIndex2017$FirstITUEntry, format="%d/%m/%Y %H:%M")
# PatIndex2017$LastITUEntry=as.POSIXct(PatIndex2017$LastITUEntry, format="%d/%m/%Y %H:%M")
} else {
warning("No Patient Info provided")
sub_pat = list()
}
}
if(filetype == 'RData'){
path_PatIndex =  choose.files()
load(path_PatIndex)
}
choose_outputs = c(0,0,1) #csv, mat, rdata --- DO NOT USE MAT, needs testing, very slow
# Option to choose maximium number of hours to process to prevent memory bottlenecks
maxhourstoprocess <- 24*30
Use7z = 1
UseZip = 0
KeepCSVs = 0
DataTypes = c("Discrete", "ECGI", "ECGII", "ECGIII", "CVP", "ART", "SPO2", "Flow", "Paw")
chooseWave2Read = select.list(DataTypes, preselect = DataTypes,
multiple = TRUE, graphics = TRUE, title = "Choose Waves to Read")
# Run functions source file
source(paste0(pathFiles,"/sourceFunctions.R"))
# Select directory containing all patients
path = choose.dir(caption="Select folder containing data repository")
#setwd(path)
listAllPatients = list.dirs(path = path, full.names = FALSE, recursive = FALSE)
#
subList = select.list(listAllPatients, preselect = NULL, multiple = TRUE,
title = NULL, graphics = TRUE )
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
PatientCode
subList
doneList = subList[1:6]
subList = subList[7:96]
doneList
subList
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
doneList
subList
doneList[7] = "z143"
subList = subList[-1]
subList
doneList
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
PatientCode
DoneList
doneList
sub_list
subList
c(doneList,subList[1:6])
doneList = c(doneList,subList[1:6])
subList = subList[7:89]
subList
DataTypes = c("Discrete", "ECGI", "ECGII", "ECGIII", "CVP", "ART", "SPO2", "Flow", "Paw")
chooseWave2Read = select.list(DataTypes, preselect = DataTypes,
multiple = TRUE, graphics = TRUE, title = "Choose Waves to Read")
chooseWave2Read = select.list(DataTypes, preselect = DataTypes,
multiple = TRUE, graphics = TRUE, title = "Choose Waves to Read")
doneList
