subList = select.list(listAllPatients, preselect = NULL, multiple = TRUE,
title = NULL, graphics = TRUE )
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
#
subList = select.list(listAllPatients, preselect = NULL, multiple = TRUE,
title = NULL, graphics = TRUE )
# path = paste0(path, "\\")
# findZ = regexpr("z[^z]*$", path)[1]
# PatientCode = substr(path, findZ, nchar(path)-1)
for (PatientCode in subList){
if(length(path_PatIndex)>0)
{
sub_pat = subset(PatIndex2017, PseudoId %in% PatientCode)
# warning("Patient not in PatientIndex") # not sure this warning is in the right place
if(nrow(sub_pat) == 0){
sub_pat = list()
print(paste0("Patient ", PatientCode , " not in PatientIndex: skipping to next patient"))
next }
}
else
{
error("No Patient Info provided")
# sub_pat = list()
}
if(sub_pat[["TotalITUTimeHRS" ]] > maxhourstoprocess)
{
print(paste0(PatientCode , " skipped as over max hours"))
next}
# Added redundacy to stop memory overload.
if(sub_pat[["TotalITUTimeHRS" ]] < maxhourstoprocess)
{
print(paste0("Processing ",PatientCode))
source(paste0(pathFiles,"/readPatient.R"))
}
if(KeepCSVs == 0)
{
for(PatientCode in subList)
{
pathIn = path
unlink(paste0(pathIn,"\\Disc_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_clean"), recursive = TRUE)
unlink(paste0(pathIn,"\\Disc_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGI_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ECGIII_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\CVP_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\ART_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\SPO2_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Flow_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\Paw_cleanMAT"), recursive = TRUE)
unlink(paste0(pathIn,"\\",PatientCode,"\\temp_zip"), recursive = TRUE)
}
}
}
793 - 511
load(choose.files())
outputdata$Meta_Data
plot(outputdata$ECGI$t , outputdata$ECGI$RR)
load(choose.files())
plot(outputdata$ECGI$t , outputdata$ECGI$RR)
outputdata$Meta_Data
{pathFiles <- setwd(paste0(choose.dir(caption="Select folder with source code."), "\\"))
source("LibrariesAndSettings.R" , print.eval  = TRUE )}
DP_LoadPatientIndex()
DP_ChooseDataReps()
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
DP_ChooseDataReps()
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
DP_ExtractPatientRecordforIndex <- function(PatIndex2017 , PatientCode){
return( subset(PatIndex2017, PseudoId %in% PatientCode))
}
PatientRecord <- DP_ExtractPatientRecordforIndex(PatIndex2017  , subList)
PatientRecord
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
if(UseReduced == "NO"){
# Load wave form data
print('Loading ECGI.')
WaveData <- DP_LoadECG(path , subList , numberrep , ECGNum = 1 )
print('ECGI Loaded.')
interestingtimepoint <- which.min( abs( difftime(
as.POSIXct( as.vector(as.character(round.POSIXt(DataSet$Data$tt , units = c('hours'))))),
as.POSIXct(select.list(as.vector(as.character(unique(round.POSIXt(
WaveData$Date[seq(from = 1, to = length(WaveData$Date) , by =1000)] , units = c('hours')))))
, preselect = PatientRecord$FirstNewAF[1]
, multiple = FALSE
, title = 'Select Interest Time Point'
, graphics = TRUE ) ), units ='hours') ))
timeindex <- which.min( abs(difftime( WaveData$Date ,  DataSet$Data$tt[interestingtimepoint[1]] , units = 'secs')) )
HoursBeforeAndAFter <- DP_SelectHoursBeforeandAfter()
ECGI <- ReturnWaveformwithPositiveOrientation(DP_CropWaveData(WaveData , timeindex , HoursBeforeAndAFter))
}
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
ASWF_SegmentChange
ASWF_SegmentChange
ASWF_CreateJumpChoices <- function(){
return(c('next Segment' , 'next 10' , 'next 100' , 'next 500' , 'next 1000' , 'previous Segment' , 'previous 10' , 'previous 100' , 'previous 500' ,'previous 1000'  , 'custom'))
}
ASWF_CreateJumpChoices()
readline()
winDialogString(message = 'Enter step and direction. ', default)
winDialogString(message = 'Enter step and direction. ')
winDialogString(message = 'Enter step and direction. ' , default = '-20')
winDialogString(message = 'Enter step and direction. For example, default is back 20.' , default = '-20')
as.numeric(winDialogString(message = 'Enter step and direction. For example, default is back 20.' , default = '-20'))
as.numeric(winDialogString(message = 'Enter step and direction. For example, default is back 20.' , default = '-20'))
as.numeric(winDialogString(message = 'Enter step and direction. For example, default is back 20.' , default = '-20'))
source('~/Github/UHSM_BHF/WaveformCode/ASWF_InteractivePatientAnalysis.R', echo=TRUE)
source('~/Github/UHSM_BHF/WaveformCode/ASWFSourceFunctions.R', echo=TRUE)
source( 'ASWF_InteractivePatientAnalysis.R'  )
ASWF_Truncatetoregionwithdata
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
StartEndTimesAF
difftime( StartEndTimesAF$End , StartEndTimesAF$End , units = 'secs' )
timeinAF <- difftime( StartEndTimesAF$End , StartEndTimesAF$Start , units = 'secs' )
timeinAF
AFScore$t
beats <- length(AFScore$t[((AFScore$t > StartEndTimesAF$Start)*(AFScore$t < StartEndTimesAF$End)) == 1 ])
beats
minbeats
minbeats <- 20*timeinAF
maxbeats <- 300*timeinAF
minbeats
maxbeats <- 300*timeinAF
timeinAF
minbeats
maxbeats
ASWF_GetStartEndAF
length(AFScore$t[((AFScore$t > StartEndTimesAF$Start)*(AFScore$t < StartEndTimesAF$End)) == 1 ])
sum(((AFScore$t > StartEndTimesAF$Start)*(AFScore$t < StartEndTimesAF$End)) == 1 )
timeinAF
beats <- sum(((AFScore$t > StartEndTimesAF$Start)*(AFScore$t < StartEndTimesAF$End)) == 1 )
beats
beats < minbeats
- as.numeric(timeinAF)
as.numeric(timeinAF)
as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
expectedmeasurments <- as.numeric(timeinAF)/as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
expectedmeasurments
sum(((ECGI$Date > StartEndTimesAF$Start)*(ECGI$Date < StartEndTimesAF$End)) == 1 )
sum(((ECGII$Date > StartEndTimesAF$Start)*(ECGII$Date < StartEndTimesAF$End)) == 1 )
sum(((ECGIII$Date > StartEndTimesAF$Start)*(ECGIII$Date < StartEndTimesAF$End)) == 1 )
numberofmeasurements = c(0,0,0)
numberofmeasurements[1] <- sum(((ECGI$Date > StartEndTimesAF$Start)*(ECGI$Date < StartEndTimesAF$End)) == 1 )
numberofmeasurements[2] <- sum(((ECGII$Date > StartEndTimesAF$Start)*(ECGII$Date < StartEndTimesAF$End)) == 1 )
numberofmeasurements[3] <- sum(((ECGIII$Date > StartEndTimesAF$Start)*(ECGIII$Date < StartEndTimesAF$End)) == 1 )
sum((numberofmeasurements / expectedmeasurments))
(numberofmeasurements / expectedmeasurments)
abs(ECGII$Date[1] - ECGII$Date[2])
abs(ECGIII$Date[1] - ECGIII$Date[2])
(numberofmeasurements / expectedmeasurments)
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
StartEndTimesAF
StartEndTimesAF[[1]]
StartEndTimesAF[1 , ]
StartEndTimesAF[-1 , ]
sum((numberofmeasurements / expectedmeasurments) < 0.75)
expectedmeasurments <- as.numeric(timeinAF)/as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
numberofmeasurements = c(0,0,0)
numberofmeasurements[1] <- sum(((ECGI$Date > StartEndTimesAF$Start[i])*(ECGI$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[2] <- sum(((ECGII$Date > StartEndTimesAF$Start[i])*(ECGII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[3] <- sum(((ECGIII$Date > StartEndTimesAF$Start[i])*(ECGIII$Date < StartEndTimesAF$End[i])) == 1 )
sum((numberofmeasurements / expectedmeasurments) < 0.75)
numberofmeasurements
numberofmeasurements / expectedmeasurments
i<-1
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
minbeats <- as.numeric(20*timeinAF)
maxbeats <- as.numeric(300*timeinAF)
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
minbeats
beats
maxbeats
beats < minbeats || beats > maxbeats
AFScore$t
AFScore$t > StartEndTimesAF$Start[i]
timeinAF
expectedmeasurments <- as.numeric(timeinAF)/as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
numberofmeasurements = c(0,0,0)
numberofmeasurements[1] <- sum(((ECGI$Date > StartEndTimesAF$Start[i])*(ECGI$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[2] <- sum(((ECGII$Date > StartEndTimesAF$Start[i])*(ECGII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[3] <- sum(((ECGIII$Date > StartEndTimesAF$Start[i])*(ECGIII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements
sum((numberofmeasurements / expectedmeasurments)
sum((numberofmeasurements / expectedmeasurments) < 0.75)
sum((numberofmeasurements / expectedmeasurments) < 0.75)
numberofmeasurements / expectedmeasurments
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
AFD_Checkformissingdata(StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII )
length(StartEndTimesAF)
length(StartEndTimesAF[ , 1]
)
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
AFD_Checkformissingdata(StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII )
length(StartEndTimesAF[ , 1])
AFD_Checkformissingdata
length(AFScore$t)
length(outputdata$ECGI$t)
length(outputdata$ECGII$t)
length(outputdata$RRCombined$t)
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
StartEndTimesAF
StartEndTimesAF[,1]
AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
StartEndTimesAF
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
StartEndTimesAF
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
timeinAF
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
View(AFD_CreateDefaultSettings)
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_InteractivePatientAnalysis.R'  )
StartEndTimesAF
AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)
InferenceOutput$StartEndTimesAF
InferenceOutput$StartEndTimesMM
StartEndTimesMM <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesMM , AFScore , ECGI , ECGII , ECGIII)
length(InferenceOutput$StartEndTimesMM)
InferenceOutput$StartEndTimesMM
InferenceOutput$StartEndTimesMM$Start
length(InferenceOutput$StartEndTimesMM$Start)
InferenceOutput <- AFD_DetectionWrapper( outputdata$RRCombined )
AFScore <- InferenceOutput$AFScore
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}
if(length(InferenceOutput$StartEndTimesMM$Start) >0 ){
StartEndTimesMM <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesMM , AFScore , ECGI , ECGII , ECGIII)}
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
InferenceOutput$StartEndTimesAF
InferenceOutput$StartEndTimesMM
InferenceOutput <- AFD_DetectionWrapper( outputdata$RRCombined )
AFScore <- InferenceOutput$AFScore
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
}
if(length(InferenceOutput$StartEndTimesMM$Start) >0 ){
StartEndTimesMM <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesMM , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesMM <- InferenceOutput$StartEndTimesMM
}
StartEndTimesMM
StartEndTimesAF
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
StartEndTimesAF
i<-1
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
timeinAF
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
minbeats
maxbeats
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
minbeats
beats < minbeats
beats < minbeats || beats > maxbeats
length(InferenceOutput$StartEndTimesAF$Start)
InferenceOutput$StartEndTimesAF
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
}
StartEndTimesAF
InferenceOutput$StartEndTimesAF
StartEndTimesAF
StartEndTimesAF
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
timeinAF
i
minbeats <- as.numeric((20/60)*timeinAF)
minbeats
maxbeats
maxbeats <- as.numeric((300/60)*timeinAF)
beats
beats < minbeats || beats > maxbeats
minbeats <- as.numeric((30/60)*timeinAF)
minbeats
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
}
StartEndTimesAF
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
}
StartEndTimesAF
StartEndTimesAF
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
minbeats <- as.numeric((30/60)*timeinAF)
minbeats
maxbeats <- as.numeric((300/60)*timeinAF)
maxbeats
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
minbeats <- as.numeric((30/60)*timeinAF)
minbeats
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
expectedmeasurments <- as.numeric(timeinAF)/as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
numberofmeasurements = c(0,0,0)
numberofmeasurements[1] <- sum(((ECGI$Date > StartEndTimesAF$Start[i])*(ECGI$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[2] <- sum(((ECGII$Date > StartEndTimesAF$Start[i])*(ECGII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[3] <- sum(((ECGIII$Date > StartEndTimesAF$Start[i])*(ECGIII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements
numberofmeasurements / expectedmeasurments
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
if(length(InferenceOutput$StartEndTimesAF$Start) >0 ){
StartEndTimesAF <- AFD_Checkformissingdata(InferenceOutput$StartEndTimesAF , AFScore , ECGI , ECGII , ECGIII)}else{
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
}
StartEndTimesAF
StartEndTimesAF
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
minbeats <- as.numeric((30/60)*timeinAF)
maxbeats <- as.numeric((300/60)*timeinAF)
minbeats
maxbeats
timeinAF
timeinAF/60
source('~/Github/UHSM_BHF/WaveformCode/AFDetectionSourceFunctions.R', echo=TRUE)
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
p1 <- ggplot(outputdata$ECGI , aes(t , RA)) +
geom_point( colour = "blue" ,  alpha=0.01 ) +
geom_point(data= outputdata$ECGII, colour = "red"  ,  alpha=0.01 ) +
geom_point(data= outputdata$ECGIII, colour = "green",  alpha=0.01 ) +
ggtitle('R-amplitudes') +
xlab("t") +
ylab("RA") + coord_cartesian(ylim = c(50, 200))
p1
seq
p1 <- ggplot(outputdata$ECGI[seq(1 , length(outputdata$ECGI$t) , 3) , ] , aes(t , RA)) +
geom_point( colour = "blue" ,  alpha=0.03 ) +
geom_point(data=outputdata$ECGII[seq(1 , length(outputdata$ECGI$t) , 3) , ] , colour = "red"  ,  alpha=0.03 ) +
geom_point(data= outputdata$ECGIII[seq(1 , length(outputdata$ECGI$t) , 3) , ] , colour = "green",  alpha=0.03 ) +
ggtitle('R-amplitudes') +
xlab("t") +
ylab("RA") + coord_cartesian(ylim = c(0, 200))
p1
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
ECGI$Value = -ECGI$Value
WaveData <- ECGI
save( WaveData , file = paste0(path , '\\' , subList , '\\Zip_out\\' ,   subList  , '_' , 'ECGI'  , '_reduced.RData' ) )
print('Extracting RA and R-R times.')
outputdata <- list()
outputdata[[1]] <- CleanRpeaks(RPeakExtractionWavelet( ECGI   , wt.filter(filter = "d6" , modwt=TRUE, level=1) , nlevels = 12 , ComponetsToKeep = c(3,4) , stdthresh = 2.5) , 2)
outputdata[[2]] <- CleanRpeaks(RPeakExtractionWavelet( ECGII  , wt.filter(filter = "d6" , modwt=TRUE, level=1) , nlevels = 12 , ComponetsToKeep = c(3,4) , stdthresh = 2.5) , 2)
outputdata[[3]] <- CleanRpeaks(RPeakExtractionWavelet( ECGIII , wt.filter(filter = "d6" , modwt=TRUE, level=1) , nlevels = 12 , ComponetsToKeep = c(3,4) , stdthresh = 2.5) , 2)
outputdata[[4]] <- PatientRecord
outputdata[[5]] <- 1
outputdata <- setNames( outputdata , c('ECGI' ,'ECGII' ,'ECGIII' , 'Meta_Data' , 'RRCombined') )
outputdata[[5]] <- PE_MultipleECGRPeaks(outputdata)
print('RA and R-R times Extracted.')
save( outputdata , file = paste0(path , '\\' , subList , '\\Zip_out\\' ,  subList  , '_RPeaks.RData' ) )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
x11()
plot(InferenceOutput$NumberModes$t , InferenceOutput$NumberModes)
plot(InferenceOutput$NumberModes$t , InferenceOutput$NumberModes$NumModes)
InferenceOutput$StartEndTimesAF
StartEndTimesAF
StartEndTimesAF <- InferenceOutput$StartEndTimesAF
i <- 6
output <- StartEndTimesAF
timeinAF <- difftime( StartEndTimesAF$End[i] , StartEndTimesAF$Start[i] , units = 'secs' )
minbeats <- as.numeric((30/60)*timeinAF)
maxbeats <- as.numeric((300/60)*timeinAF)
minbeats
maxbeats
beats <- sum(((AFScore$t > StartEndTimesAF$Start[i])*(AFScore$t < StartEndTimesAF$End[i])) == 1 )
beats
expectedmeasurments <- as.numeric(timeinAF)/as.numeric(abs(ECGI$Date[1] - ECGI$Date[2]))
expectedmeasurments
numberofmeasurements = c(0,0,0)
numberofmeasurements[1] <- sum(((ECGI$Date > StartEndTimesAF$Start[i])*(ECGI$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[2] <- sum(((ECGII$Date > StartEndTimesAF$Start[i])*(ECGII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements[3] <- sum(((ECGIII$Date > StartEndTimesAF$Start[i])*(ECGIII$Date < StartEndTimesAF$End[i])) == 1 )
numberofmeasurements / expectedmeasurments
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
DP_checkfilesprocessed
DP_checkfilesprocessed(path , subList , 'ECGI')
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
DP_checkfilesprocessed(path , subList , 'ECGI')
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
PatientRecord$TotalITUTimeHRS
PatientRecord
subList
subList <- 'z1144'
PatientRecord <- DP_ExtractPatientRecordforIndex(PatIndex2017  , subList)
PatientRecord$TotalITUTimeHRS
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
source( 'ASWF_ChooseLoadandProcessPatient.R' )
source( 'ASWF_InteractivePatientAnalysis.R'  )
